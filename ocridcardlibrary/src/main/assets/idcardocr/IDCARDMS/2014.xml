<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE IDCARD SYSTEM "IDCARD.dtd">
<IDCARD>
  <CIDCardTemplate nMainDocumentID="2014" chDocumentName="墨西哥选民证背面ABC" engDocumentName="Mexico INE&IFE ID Card Reverse Page" imageSizeType="2">
    <vecAutoProcess>
	    <!--导入识别-->
		<vecProcessMode nMode="0"> 
			<!--CAutoProcess processType="22">
			  <CIDCardAutoProcessEx nCropType="0" bCrop="1" nRotateType="3" bRotate="1" nMaxAngle="0.3" nMinAngle="0.017" nFilledType="1" bTilt="1" bSameSize="1" bResize="1" nWidth="1008" nHeight="638"/> 
			</CAutoProcess-->  
			<CAutoProcess processType="25">
			  <PerspectiveTransformEx nType="99" nWidth="896" nHeight="569"/> 
			</CAutoProcess> 
		</vecProcessMode>
		<!--视频流-->
        <vecProcessMode nMode="1"> 
			<!--CAutoProcess processType="23">
			  <CIDCardAutoProcessEx2 nCropType="4" nMaxAngle="0.3" nMinAngle="0.017" nFilledType="1" bIs180Rotate="0" bIsValid="0"  bSameSize="1"/> 
			</CAutoProcess-->  
			<CAutoProcess processType="24">
			  <PerspectiveTransform nType="3" bIs180Rotate="1" bIsValid="1" nWidth="896" nHeight="569"/> 
			</CAutoProcess>  
		</vecProcessMode>
    </vecAutoProcess>
	<vecProcessImage>
      <CProcessImage processType="3">
        <CEraseBlackBorderEx>
          <!--processRect要检测黑边的区域-->
          <RECT Left="0" Top="0" Right="10000" Bottom="10000" />
          <!--unProcessRect在要检测的区域里，能够确定的不需要检测黑边的部分，

					也就是说这个区域肯定没有黑边存在，用来提高检测效-->
          <RECT Left="800" Top="800" Right="9200" Bottom="9800" />
        </CEraseBlackBorderEx>
      </CProcessImage>
		<CProcessImage processType="12">
			<CRotateEx nRotateType="1"/> 
		</CProcessImage>
    </vecProcessImage>
    <!--vecAnchor:该证件的所有的基准点的信息-->
    <!--anchorType:基准点类型，取值如下

			ZEROANCHOR=0,//(0,0)基准
			LEFT=1,//左边
			RIGHT=2,//右边
			TOP=3,//上边
			BOTTOM=4,//下边
		-->
    <vecRegion>
		<CRegion nIndex="0" nRegionType="1" nProcessOrder="0">
						<!--处理该区域需要的图像信息的光的类型-->
					<vecImageLightType>
						  <!--1:可见光图;2:红外光图;4:紫外光图-->
						  <LIGHTTYPE>1</LIGHTTYPE>
						  <LIGHTTYPE>2</LIGHTTYPE>
					</vecImageLightType>
						<!--定义区域的定位信息,如果是头像区域还需要进一步精确定位，识别区域就不用了-->
						<!--bAccurateLocate为1表示需要进一步精确定位,0代表不需要-->
					<CLocateRegion bAccurateLocate="0">
						  <!--在定位前进行的预处理信息，一般是二值化-->
						  <vecProcessImage>

						  </vecProcessImage>
						  <!--rcMinRect:指定定位区域的最小范围，即定位后的区域范围必须包含这个区域-->
						  <RECT Left="9999" Top="9999" Right="0" Bottom="0" />
						  <vecAnchorLocateInfo>
							<!--nDisToAnchor的值也是整图的百分比*10000计算出来的-->
							<CAnchorLocateInfo nAnchorIndex="0" nDisToAnchor="1400" anchorType="1" />
							<CAnchorLocateInfo nAnchorIndex="0" nDisToAnchor="7348" anchorType="2" />
							<CAnchorLocateInfo nAnchorIndex="0" nDisToAnchor="200" anchorType="3" />
							<CAnchorLocateInfo nAnchorIndex="0" nDisToAnchor="814" anchorType="4" />
						  </vecAnchorLocateInfo>
						  <!--该区域定义的区域类型基准点的信息-->
						  <vecCLocateAnchor></vecCLocateAnchor>
					</CLocateRegion>
						<!--区域内定位行的信息-->
					<CLocateLine>
						  <!--rcHorizontal：进行行的左右边界定位时的区域范围，坐标单位为所在区域的百分比*100-->
						  <RECT Left="0" Top="0" Right="100" Bottom="100" />
						  <!--rcVertical：进行行的上下边界定位时的区域范围，坐标单位为所在区域的百分比*100-->
						  <RECT Left="20" Top="0" Right="90" Bottom="100" />
						  <!--nLocateMethod:灰度变化的方式进行行定位1，投影方式进行行定位-->
						  <!--bHeight:是否等高-->
						  <!--bSpace:是否等间距-->
						  <!--bWidth:是否等宽-->
						  <!--nMinElementNum:该行最少元素数-->
						  <!--nMaxElementNum:该行最多元素数-->
						  <!--nMinWidth:元素的最小宽度-->
						  <!--nMaxWidth:元素的最大宽度-->
						  <!--nMinHeight:元素的最小高度-->
						  <!--nMaxHeight:元素的最大高度-->
						  <!--nMinSpace:元素间的最小间距-->
						  <!--nMaxSpace:元素间的最大间距-->
						  <CLocateInfo bEraseStart="0" nMinWHRatio="0" nMaxWHRatio="160" nSplitWHRatio="2000" bSplit="0" nNumType="0" bSpace="0" bWidth="0" bHeight="0" bRemoveLineNoise="0" nMinElementNum="1" nMaxElementNum="1" nMinWidth="500" nMaxWidth="9999" nMinHeight="200" nMaxHeight="540" nMinSpace="200" nMaxSpace="400" bPostProcess="1">
							<vecCLocateMethod>
							  <CLocateMethod nLocateMethod="1">
								<!--在定位前进行的预处理信息，一般是二值化-->
								<vecProcessImage>
								  <CProcessImage processType="1">
									<CTrueColorToGrayEx nFilter="1">
									  <!--processRect-->
									  <RECT Top="0" Right="0" Bottom="0" Left="0" />
									</CTrueColorToGrayEx>
								  </CProcessImage>
								  <CProcessImage processType="2">
									<CGrayToBinaryEx>
									  <vecBinaryParam>
										<BINARYPARAM nBlockNum="2" nMethod="8" /> 
									  </vecBinaryParam>
									  <!--processRect-->
									  <RECT Left="0" Top="0" Right="0" Bottom="0" />
									</CGrayToBinaryEx>
								  </CProcessImage>
								</vecProcessImage>
							  </CLocateMethod>
							  <CLocateMethod nLocateMethod="0">
								<!--在定位前进行的预处理信息，一般是二值化-->
								<vecProcessImage>
								  <CProcessImage processType="1">
									<CTrueColorToGrayEx nFilter="1">
									  <!--processRect-->
									  <RECT Top="0" Right="0" Bottom="0" Left="0" />
									</CTrueColorToGrayEx>
								  </CProcessImage>
								</vecProcessImage>
							  </CLocateMethod>
							
							</vecCLocateMethod>
						  </CLocateInfo>
						  <!--采用定位算法对行定位后，边界要浮动的大小，可以为负数
									也是整图的百分比*10000计算出来的-->
						  <positionPlus nLeftPlus="-80" nRightPlus="200" nTopPlus="-200" nBottomPlus="150" />
					</CLocateLine>
						<!--该区域里的行的具体信息，里面行的位置信息可以有初始值-->
					<vecLine>
						  <!--nIndex:该行在区域内是第几行，以第一行或者最后一行为基准从0开始的偏移-->
						  <!--bStartOffset:如果是以区域的第一行为基准，该值为true,否则为false-->
						  <!--bEndOffset:如果是以区域的最后一行为基准，该值为false，否则为false-->
						  <!--nLineType:0代表不需要识别，1代表需要识别-->
						  <CLine nIndex="0" bStartOffset="1" bEndOffset="0" bExist="1" bNeedRecog="1" nCheckKeyWord="0">
							<!--rcLineResult:行的初始位置信息，初始值尽量写最小的区域范围，这样最准确
											如果都为0代表该值不可靠，坐标单位为坐标均为占整张图像的百分比*10000
										-->
							<RECT Left="0" Top="0" Right="0" Bottom="0" />
							<vecRecogInfo>
<CRecogInfo bIgnorePoint="0" nMaxPointWidth="0" nMaxPointHeight="0" bMatchRegExp="1" charOrder="\D{13}" bConfirmParams="0" nProcessOrder="0" nKernelType="0">
							  <!--定位字符的信息-->
							  <!--nLocateMethod:  0,用识别核心做定位;
																	1，提取连通域的方法进行定位;
																	2，投影方法进行定位
												-->
							  <!--bHeight:是否等高-->
							  <!--bSpace:是否等间距-->
							  <!--bWidth:是否等宽-->
							  <!--nMinElementNum:该行最少元素数-->
							  <!--nMaxElementNum:该行最多元素数-->
							  <!--nMinWidth:元素的最小宽度-->
							  <!--nMaxWidth:元素的最大宽度-->
							  <!--nMinHeight:元素的最小高度-->
							  <!--nMaxHeight:元素的最大高度-->
							  <!--nMinSpace:元素间的最小间距-->
							  <!--nMaxSpace:元素间的最大间距-->
							  <CLocateInfo bEraseStart="0" nMinWHRatio="0" nMaxWHRatio="100" nSplitWHRatio="2000" bSplit="0" nNumType="0" bSpace="0" bWidth="0" bHeight="0" bRemoveLineNoise="0" nMinElementNum="12" nMaxElementNum="13" nMinWidth="100" nMaxWidth="350" nMinHeight="250" nMaxHeight="560" nMinSpace="20" nMaxSpace="200" bPostProcess="1">
								<vecCLocateMethod>
								  <CLocateMethod nLocateMethod="1">
									<!--在定位前进行的预处理信息-->
									<vecProcessImage>
									  <CProcessImage processType="1">
										<CTrueColorToGrayEx nFilter="0">
										  <!--processRect-->
										  <RECT Top="0" Right="0" Bottom="0" Left="0" />
										</CTrueColorToGrayEx>
									  </CProcessImage>
									  <CProcessImage processType="2">
										<CGrayToBinaryEx>
										  <vecBinaryParam>
											<BINARYPARAM nBlockNum="1" nMethod="8" />
										  </vecBinaryParam>
										  <!--processRect-->
										  <RECT Left="0" Top="0" Right="0" Bottom="0" />
										</CGrayToBinaryEx>
									  </CProcessImage>
									</vecProcessImage>
								  </CLocateMethod>
								  <CLocateMethod nLocateMethod="1">
									<!--在定位前进行的预处理信息-->
									<vecProcessImage>
									  <CProcessImage processType="1">
										<CTrueColorToGrayEx nFilter="0">
										  <!--processRect-->
										  <RECT Top="0" Right="0" Bottom="0" Left="0" />
										</CTrueColorToGrayEx>
									  </CProcessImage>
									  <CProcessImage processType="2">
										<CGrayToBinaryEx>
										  <vecBinaryParam>
											<BINARYPARAM nBlockNum="1" nMethod="6" />
										  </vecBinaryParam>
										  <!--processRect-->
										  <RECT Left="0" Top="0" Right="0" Bottom="0" />
										</CGrayToBinaryEx>
									  </CProcessImage>
									</vecProcessImage>
								  </CLocateMethod>
								</vecCLocateMethod>
							  </CLocateInfo>
							  <vecKernal>
								<!--nRecogType:0识别区域，1识别字符-->
								<!--nRecogImgeType:进行识别时需要的图像类型，0代表灰度，1代表二值-->
								<CKernalInfo kernalMainType="1" nKernalSubType="22" nFilterType="256" nFillingMethod="1" strFilterPlus="" nRecogType="1" nRecogImgeType="0">
									<vecCharRatio>
										<CCharRatio strChars="" charType="2" nWHRatio="80"/>
										
									</vecCharRatio>
								</CKernalInfo> 
								
							  </vecKernal>
							</CRecogInfo>
</vecRecogInfo>
<!--cellRecogType:识别内容
												NAMECH=0,//中文姓名
												SEX=1,//性别
												NATION=2,//民族
												BIRTHDAY=3,//出生日期
												ISSUINGDATE=4,//签发日期
												VALIDPERIOD=5,//有效期至
												ADDRESSS=6,//地址
												IDNUMBER=7,//身份证号码
												PPMRZ1=8,//护照类型证件的机读码第一行
												PPMRZ2=9,//护照类型证件的机读码第二行
												OTHER=10//其他类型
										-->
							<!--charOrder:字符的排列情况，用正则表达式表示-->
							<!--kernalMainType识别核心主类型 
												TH_OCR=1,
												SSFT152=2,
												BARCODE=3
										-->
							<!--行内识别单元的信息-->
							<vecRecogUnit>
							  <!--nIndex:识别单元序号-->
							  <!--cellNameEng="" cellName:识别单元名称-->
							  <!--bLocate:该识别单元是否需要定位-->
							  <!--bReRecog:该识别单元是否需要重新识别-->
							  <!--OutputThreshold:输出界限一，待输出的识别结果的字频的值不能低于该值-->
							  <!--输出界限二，字频值< OutputThreshold的个数最大不能超过该值，否则将不输出-->
							  <CRecogUnit nIndex="1" bLocate="0" bRecog="0">
<vecRecogInfo/>
</CRecogUnit>
							</vecRecogUnit>
							<!--vecLineKeyWord:记录该行内用来定位的关键字信息-->
							<vecLineKeyWord></vecLineKeyWord>
							<!--vecAnchor:记录该行定义基准点的信息-->
							<vecCLocateAnchor></vecCLocateAnchor>
						  </CLine>
						 
					</vecLine>
		</CRegion>
    </vecRegion>
    <vecAnchor>
      <CAnchor nIndex="0" anchorType="0" anchorPos="0" bEnable="0" nMinPos="-1" nMaxPos="-1" />
    </vecAnchor>
    <vecOutPutResult>
      <COutPutResult nIndex="0" cellRecogType="20" cellNameEng="Reserved" cellName="保留" nOutputThreshold="0" nOutputNumber="0" bFormatResult="0" />
      <COutPutResult nIndex="1" cellRecogType="20" cellNameEng="CURP" cellName="身份唯一标识" nOutputThreshold="0" nOutputNumber="0" bFormatResult="0" bMainField="1" nRejectThresh="18"/>
  
	</vecOutPutResult>
    <vecMergeUnit>
	</vecMergeUnit>
	
  </CIDCardTemplate>
  </IDCARD>